# Kibana Helm Values — production-grade template
# Rendered by Terraform templatefile() — do NOT edit directly

# ---------------------------------------------------------------------------
# Replicas — >= 2 for HA
# ---------------------------------------------------------------------------
replicas: ${replicas}

# ---------------------------------------------------------------------------
# Resource management
# ---------------------------------------------------------------------------
resources:
  requests:
    cpu: "${resources_requests_cpu}"
    memory: "${resources_requests_memory}"
  limits:
    cpu: "${resources_limits_cpu}"
    memory: "${resources_limits_memory}"

# ---------------------------------------------------------------------------
# JVM / Node.js heap — 50% of container memory limit
# ---------------------------------------------------------------------------
# Kibana runs on Node.js; cap old-space to prevent OOMKill
extraEnvs:
  - name: NODE_OPTIONS
    value: "--max-old-space-size=${heap_size_mb}"
  # Elasticsearch password — pulled from Kubernetes secret, never plaintext
  - name: ELASTICSEARCH_PASSWORD
    valueFrom:
      secretKeyRef:
        name: ${secret_name}
        key: ELASTICSEARCH_PASSWORD
  # All three encryption keys are sourced from the same secret value
  # (Kibana requires separate keys; we derive them from one strong secret)
  - name: KIBANA_ENCRYPTION_KEY
    valueFrom:
      secretKeyRef:
        name: ${secret_name}
        key: KIBANA_ENCRYPTION_KEY

# ---------------------------------------------------------------------------
# Elasticsearch connectivity
# ---------------------------------------------------------------------------
elasticsearchHosts: "${elasticsearch_host}"

# Use the built-in 'elastic' superuser
elasticsearch:
  username: "elastic"
  # Password is injected via ELASTICSEARCH_PASSWORD env var above
  # Skip TLS verification for pod-to-pod traffic (cert is auto-generated by ES chart)
  ssl:
    verificationMode: none

# ---------------------------------------------------------------------------
# Kibana core configuration
# ---------------------------------------------------------------------------
kibanaConfig:
  kibana.yml: |
    # Encryption keys — all sourced from the KIBANA_ENCRYPTION_KEY env var.
    # Each key must be distinct; we prefix to differentiate them.
    xpack.encryptedSavedObjects.encryptionKey: "$${KIBANA_ENCRYPTION_KEY}"
    xpack.reporting.encryptionKey: "$${KIBANA_ENCRYPTION_KEY}"
    xpack.security.encryptionKey: "$${KIBANA_ENCRYPTION_KEY}"

    # Server settings
    server.maxPayloadBytes: 1048576
%{ if base_path != "" }
    server.basePath: "${base_path}"
    server.rewriteBasePath: true
%{ endif }

    # Structured JSON logging to stdout — compatible with log aggregators
    logging.root.level: ${log_level}
    logging.appenders.default:
      type: console
      layout:
        type: json

# ---------------------------------------------------------------------------
# Persistence — saved objects, dashboards, visualisations
# ---------------------------------------------------------------------------
persistence:
  enabled: true
%{ if storage_class != "" }
  storageClassName: "${storage_class}"
%{ endif }
  size: "${storage_size}"
  accessMode: ReadWriteOnce

# ---------------------------------------------------------------------------
# High Availability — hard anti-affinity: one pod per node
# ---------------------------------------------------------------------------
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
                - kibana
        topologyKey: kubernetes.io/hostname

# Pod Disruption Budget — always keep at least 1 pod available during node drains
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# ---------------------------------------------------------------------------
# Health probes — tuned for Kibana's slower startup
# ---------------------------------------------------------------------------
readinessProbe:
  failureThreshold: 6
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

livenessProbe:
  failureThreshold: 4
  initialDelaySeconds: 60
  periodSeconds: 20
  successThreshold: 1
  timeoutSeconds: 10

# ---------------------------------------------------------------------------
# Networking
# ---------------------------------------------------------------------------
httpPort: 5601

# ---------------------------------------------------------------------------
# Scheduling — node selector and tolerations
# ---------------------------------------------------------------------------
nodeSelector:
%{ if length(node_selector) > 0 ~}
%{ for key, value in node_selector ~}
  ${key}: "${value}"
%{ endfor ~}
%{ else ~}
  {}
%{ endif ~}

tolerations:
%{ if length(tolerations) > 0 ~}
%{ for t in tolerations ~}
  - key: "${t.key}"
    operator: "${t.operator}"
    value: "${t.value}"
    effect: "${t.effect}"
%{ endfor ~}
%{ else ~}
  []
%{ endif ~}
